[{"id":"auto_setup_flow_trigger","type":"inject","z":"auto_setup_flow_tab","name":"Run Auto Setup","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":140,"y":100,"wires":[[ "read_address_map" ]]},{"id":"read_address_map","type":"file in","z":"auto_setup_flow_tab","name":"Read Address Map","filename":"/usr/src/node-red/config/plc_address_map_example.json","filenameType":"str","format":"utf8","chunk":false,"sendError":false,"encoding":"none","allProps":false,"x":340,"y":100,"wires":[[ "parse_json" ]]},{"id":"parse_json","type":"json","z":"auto_setup_flow_tab","name":"Parse JSON","property":"payload","action":"","pretty":false,"x":530,"y":100,"wires":[[ "generate_flow_json" ]]},{"id":"generate_flow_json","type":"function","z":"auto_setup_flow_tab","name":"Generate Flow JSON","func":"const addressMap = msg.payload;\n\n// Generate a unique ID for the new flow tab\nconst newFlowTabId = RED.util.generateId();\nconst newFlowTabName = \"Auto Generated Modbus Flows\";\n\nconst newFlow = {\n    \"id\": newFlowTabId,\n    \"type\": \"tab\",\n    \"label\": newFlowTabName,\n    \"disabled\": false,\n    \"info\": \"Flows automatically generated from PLC address map\"\n};\n\nconst nodes = [newFlow];\nconst modbusServerId = RED.util.generateId();\nconst mqttBrokerId = RED.util.generateId();\n\n// Add a single Modbus Server config node for all Modbus Read nodes to share\n// User needs to manually configure this server after deployment\nnodes.push({\n    \"id\": modbusServerId,\n    \"type\": \"modbus-client\",\n    \"name\": \"Modbus TCP Client\",\n    \"server\": \"127.0.0.1\", // Placeholder: User must change to actual PLC IP\n    \"port\": \"502\",\n    \"unit_id\": \"1\",\n    \"tcp_type\": \"DEFAULT\",\n    \"x\": 0, // Not visible on flow, just a config node\n    \"y\": 0, // Not visible on flow\n    \"wires\": [],\n    \"_users\": [] // This will be populated by Node-RED when nodes link to it\n});\n\n// Add a single MQTT Broker config node for all MQTT Out nodes to share\nnodes.push({\n    \"id\": mqttBrokerId,\n    \"type\": \"mqtt-broker\",\n    \"name\": \"MQTT Broker\",\n    \"broker\": \"mosquitto\", // Service name in docker-compose\n    \"port\": \"1883\",\n    \"clientid\": \"node-red-client\",\n    \"usetls\": false,\n    \"compatmode\": false,\n    \"keepalive\": \"60\",\n    \"cleansession\": true,\n    \"x\": 0,\n    \"y\": 0,\n    \"wires\": [],\n    \"_users\": []\n});\n\naddressMap.forEach(item => {\n    const modbusReadNodeId = RED.util.generateId();\n    const functionNodeId = RED.util.generateId();\n    const mqttOutNodeId = RED.util.generateId();\n\n    // Modbus Read Node\n    nodes.push({\n        \"id\": modbusReadNodeId,\n        \"type\": \"modbus-read\",\n        \"z\": newFlowTabId, // Assign to the new flow tab\n        \"name\": `Read ${item.name}`,
        \"topic\": item.name,\n        \"showStatusActivities\": false,\n        \"showErrors\": false,\n        \"unitid\": item.unitId || \"1\", // Use item.unitId if provided, else default to 1\n        \"dataType\": item.functionCode, // e.g., \"Holding Registers\", \"Coils\"\n        \"adr\": item.address - (item.functionCode.includes(\"Registers\") ? 40000 : 0), // Adjust for 0-based addressing if needed\n        \"quantity\": item.quantity,\n        \"rate\": item.pollingRate || \"1 second\",\n        \"rateUnit\": \"1 second\",\n        \"server\": modbusServerId, // Link to the shared Modbus Server config node\n        \"ieee_address_offset\": \"\",\n        \"x\": 200,\n        \"y\": 100 + nodes.length * 80, // Position nodes vertically\n        \"wires\": [\n            [functionNodeId]\n        ]\n    });\n\n    // Function Node for Data Type Conversion and Scaling\n    let funcCode = `\n        let value = msg.payload.data;\n        let result = value;\n\n        // Data Type Conversion\n        switch ('${item.dataType}') {\n            case 'int16':\n                // Already int16, no special conversion needed for single register\n                result = value[0];\n                break;\n            case 'int32':\n                // Assuming two 16-bit registers for 32-bit int\n                // Need to handle endianness\n                if (value.length >= 2) {\n                    let buffer = Buffer.alloc(4);\n                    if ('${item.endianness}' === 'little-endian') {\n                        buffer.writeUInt16LE(value[0], 0);\n                        buffer.writeUInt16LE(value[1], 2);\n                    } else { // Default to big-endian\n                        buffer.writeUInt16BE(value[0], 0);\n                        buffer.writeUInt16BE(value[1], 2);\n                    }\n                    result = buffer.readInt32BE(0); // Assuming Big-Endian for read, adjust if needed\n                }\n                break;\n            case 'float32':\n                // Assuming two 16-bit registers for 32-bit float\n                if (value.length >= 2) {\n                    let buffer = Buffer.alloc(4);\n                    if ('${item.endianness}' === 'little-endian') {\n                        buffer.writeUInt16LE(value[0], 0);\n                        buffer.writeUInt16LE(value[1], 2);\n                    }\n                    result = buffer.readFloatBE(0); // Assuming Big-Endian for read, adjust if needed\n                }\n                break;\n            case 'boolean':\n                // For coils/discrete inputs, value[0] is 0 or 1\n                result = (value[0] === 1);\n                break;\n            // Add more data types as needed\n        }\n\n        // Scaling\n        if (${item.scaling && item.scaling.factor !== undefined}) {\n            result = result * ${item.scaling.factor};\n        }\n        if (${item.scaling && item.scaling.offset !== undefined}) {\n            result = result + ${item.scaling.offset};\n        }\n\n        msg.payload = result;\n        msg.topic = 'plc/data/${item.name}'; // MQTT Topic\n        msg.unit = '${item.unit || ''}';\n        return msg;\n    `;\n\n    nodes.push({\n        \"id\": functionNodeId,\n        \"type\": \"function\",\n        \"z\": newFlowTabId,\n        \"name\": `Process ${item.name}`,\n        \"func\": funcCode,\n        \"outputs\": 1,\n        \"noerr\": 0,\n        \"initialize\": \"\",\n        \"finalize\": \"\",\n        \"libs\": [],\n        \"x\": 400,\n        \"y\": 100 + nodes.length * 80,\n        \"wires\": [\n            [mqttOutNodeId]\n        ]\n    });\n\n    // MQTT Out Node\n    nodes.push({\n        \"id\": mqttOutNodeId,\n        \"type\": \"mqtt out\",\n        \"z\": newFlowTabId,\n        \"name\": `Publish ${item.name} to MQTT`,
        \"topic\": `plc/data/${item.name}`,
        \"qos\": \"0\",\n        \"retain\": \"false\",\n        \"broker\": mqttBrokerId,\n        \"x\": 600,\n        \"y\": 100 + nodes.length * 80,\n        \"wires\": []\n    });\n});\n\nmsg.payload = nodes;\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":730,"y":100,"wires":[[ "deploy_flow" ]]},{"id":"deploy_flow","type":"http request","z":"auto_setup_flow_tab","name":"Deploy Flow via Admin API","method":"POST","ret":"txt","paytoqs":"body","url":"http://localhost:1880/red/flows","tls":"","persist":false,"proxy":"","insecureHTTPParser":false,"authType":"bearer","senderr":"false","headers":[{"p":"Content-Type","v":"application/json"},{"p":"Authorization","v":"Bearer YOUR_ADMIN_API_TOKEN"}],"x":1000,"y":100,"wires":[[ "deploy_result" ]]},{"id":"deploy_result","type":"debug","z":"auto_setup_flow_tab","name":"Deploy Result","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1200,"y":100,"wires":[]},{"id":"auto_setup_flow_tab","type":"tab","label":"Automated Setup Flow","disabled":false,"info":""}]